package com.hotelbooking.service;

import com.hotelbooking.model.Booking;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Unit tests for the BookingService class, which now uses an in-memory store.
 */
class BookingServiceTest {

    private BookingService bookingService;

    @BeforeEach
    void setUp() {
        // Initialize a new BookingService for each test to ensure isolation
        bookingService = new BookingService();
    }

    @Test
    @DisplayName("Should create a new booking successfully")
    void shouldCreateBookingSuccessfully() {
        Booking newBooking = new Booking(null, "Test Hotel", "John Doe",
                LocalDate.now().plusDays(10), LocalDate.now().plusDays(15), null);

        Booking createdBooking = bookingService.createBooking(newBooking);

        assertNotNull(createdBooking);
        assertNotNull(createdBooking.getId()); // ID should be generated by the service
        assertEquals("Test Hotel", createdBooking.getHotelName());
        assertEquals("John Doe", createdBooking.getGuestName());
        assertEquals("PENDING", createdBooking.getStatus()); // Default status

        // Verify it exists in the in-memory store
        assertTrue(bookingService.getBookingById(createdBooking.getId()).isPresent());
    }

    @Test
    @DisplayName("Should throw IllegalArgumentException for invalid booking dates (check-in after check-out)")
    void shouldThrowExceptionForInvalidBookingDates() {
        Booking invalidBooking = new Booking(null, "Bad Hotel", "Jane Doe",
                LocalDate.now().plusDays(15), LocalDate.now().plusDays(10), null);

        assertThrows(IllegalArgumentException.class, () -> bookingService.createBooking(invalidBooking));
    }

    @Test
    @DisplayName("Should throw IllegalArgumentException for past check-in date")
    void shouldThrowExceptionForPastCheckInDate() {
        Booking invalidBooking = new Booking(null, "Past Hotel", "Old Guest",
                LocalDate.now().minusDays(5), LocalDate.now().plusDays(5), null);

        assertThrows(IllegalArgumentException.class, () -> bookingService.createBooking(invalidBooking));
    }

    @Test
    @DisplayName("Should retrieve a booking by ID successfully")
    void shouldGetBookingByIdSuccessfully() {
        Booking createdBooking = bookingService.createBooking(new Booking(null, "Retrieve Hotel", "Alice",
                LocalDate.now().plusDays(1), LocalDate.now().plusDays(2), "CONFIRMED"));

        Optional<Booking> foundBooking = bookingService.getBookingById(createdBooking.getId());

        assertTrue(foundBooking.isPresent());
        assertEquals(createdBooking.getId(), foundBooking.get().getId());
        assertEquals("Retrieve Hotel", foundBooking.get().getHotelName());
    }

    @Test
    @DisplayName("Should return empty optional if booking not found by ID")
    void shouldReturnEmptyIfBookingNotFound() {
        String nonExistentId = UUID.randomUUID().toString();
        Optional<Booking> foundBooking = bookingService.getBookingById(nonExistentId);
        assertFalse(foundBooking.isPresent());
    }

    @Test
    @DisplayName("Should retrieve all bookings successfully")
    void shouldGetAllBookingsSuccessfully() {
        // Initial data is already present from constructor
        List<Booking> initialBookings = bookingService.getAllBookings();
        assertTrue(initialBookings.size() >= 3); // At least 3 initial bookings

        bookingService.createBooking(new Booking(null, "Hotel A", "Guest A", LocalDate.now(), LocalDate.now().plusDays(1), "CONFIRMED"));
        bookingService.createBooking(new Booking(null, "Hotel B", "Guest B", LocalDate.now(), LocalDate.now().plusDays(2), "PENDING"));

        List<Booking> allBookings = bookingService.getAllBookings();

        assertNotNull(allBookings);
        assertTrue(allBookings.size() > initialBookings.size()); // Should have more than initial
    }

    @Test
    @DisplayName("Should update an existing booking successfully")
    void shouldUpdateBookingSuccessfully() {
        Booking existingBooking = bookingService.createBooking(new Booking(null, "Old Hotel", "Old Guest",
                LocalDate.now().plusDays(1), LocalDate.now().plusDays(5), "CONFIRMED"));

        Booking updatedDetails = new Booking(null, "New Hotel Name", "New Guest Name", // ID is null as it comes from request body
                LocalDate.now().plusDays(2), LocalDate.now().plusDays(6), "CONFIRMED");

        Optional<Booking> result = bookingService.updateBooking(existingBooking.getId(), updatedDetails);

        assertTrue(result.isPresent());
        assertEquals(existingBooking.getId(), result.get().getId()); // ID should be preserved
        assertEquals("New Hotel Name", result.get().getHotelName());
        assertEquals("New Guest Name", result.get().getGuestName());
        assertEquals("CONFIRMED", result.get().getStatus());

        // Verify in the in-memory store
        Booking storedBooking = bookingService.getBookingById(existingBooking.getId()).orElseThrow();
        assertEquals("New Hotel Name", storedBooking.getHotelName());
    }

    @Test
    @DisplayName("Should return empty optional if booking not found for update")
    void shouldReturnEmptyIfBookingNotFoundForUpdate() {
        String nonExistentId = UUID.randomUUID().toString();
        Booking updatedDetails = new Booking(null, "Non Existent Update", "Guest",
                LocalDate.now().plusDays(2), LocalDate.now().plusDays(6), "CONFIRMED");

        Optional<Booking> result = bookingService.updateBooking(nonExistentId, updatedDetails);

        assertFalse(result.isPresent());
    }

    @Test
    @DisplayName("Should cancel a booking successfully")
    void shouldCancelBookingSuccessfully() {
        Booking existingBooking = bookingService.createBooking(new Booking(null, "Cancel Hotel", "Guest C",
                LocalDate.now().plusDays(1), LocalDate.now().plusDays(5), "CONFIRMED"));

        boolean cancelled = bookingService.cancelBooking(existingBooking.getId());

        assertTrue(cancelled);
        // Verify the status was updated to CANCELLED in the in-memory store
        Booking storedBooking = bookingService.getBookingById(existingBooking.getId()).orElseThrow();
        assertEquals("CANCELLED", storedBooking.getStatus());
    }

    @Test
    @DisplayName("Should return false if booking not found for cancellation")
    void shouldReturnFalseIfBookingNotFoundForCancel() {
        String nonExistentId = UUID.randomUUID().toString();
        boolean cancelled = bookingService.cancelBooking(nonExistentId);
        assertFalse(cancelled);
    }

    @Test
    @DisplayName("Should return false if booking is already cancelled")
    void shouldReturnFalseIfBookingAlreadyCancelled() {
        Booking existingBooking = bookingService.createBooking(new Booking(null, "Hotel X", "Guest X",
                LocalDate.now().plusDays(1), LocalDate.now().plusDays(5), "CONFIRMED"));
        existingBooking.setStatus("CANCELLED"); // Manually set to cancelled

        boolean cancelled = bookingService.cancelBooking(existingBooking.getId());
        assertFalse(cancelled); // Should return false as it's already cancelled
    }

    @Test
    @DisplayName("Should delete a booking successfully")
    void shouldDeleteBookingSuccessfully() {
        Booking existingBooking = bookingService.createBooking(new Booking(null, "Delete Hotel", "Guest D",
                LocalDate.now().plusDays(1), LocalDate.now().plusDays(2), "PENDING"));

        boolean deleted = bookingService.deleteBooking(existingBooking.getId());

        assertTrue(deleted);
        // Verify it no longer exists in the in-memory store
        assertFalse(bookingService.getBookingById(existingBooking.getId()).isPresent());
    }

    @Test
    @DisplayName("Should return false if booking not found for deletion")
    void shouldReturnFalseIfBookingNotFoundForDelete() {
        String nonExistentId = UUID.randomUUID().toString();
        boolean deleted = bookingService.deleteBooking(nonExistentId);
        assertFalse(deleted);
    }

    @Test
    @DisplayName("Should throw IllegalArgumentException for null booking ID on get")
    void shouldThrowExceptionForNullBookingIdOnGet() {
        assertThrows(IllegalArgumentException.class, () -> bookingService.getBookingById(null));
    }

    @Test
    @DisplayName("Should search bookings by hotel name successfully")
    void shouldSearchBookingsByHotelName() {
        // Initial data includes "Grand Hyatt" and "Grand Hotel & Casino"
        List<Booking> results = bookingService.searchBookingsByHotelName("Grand");
        assertFalse(results.isEmpty());
        assertEquals(2, results.size());
        assertTrue(results.stream().anyMatch(b -> b.getHotelName().equals("Grand Hyatt")));
        assertTrue(results.stream().anyMatch(b -> b.getHotelName().equals("Grand Hotel & Casino")));

        // Case-insensitive search
        results = bookingService.searchBookingsByHotelName("hilton");
        assertFalse(results.isEmpty());
        assertEquals(1, results.size());
        assertTrue(results.stream().anyMatch(b -> b.getHotelName().equals("Hilton Garden Inn")));

        // Partial match
        results = bookingService.searchBookingsByHotelName("marq");
        assertFalse(results.isEmpty());
        assertEquals(1, results.size());
        assertTrue(results.stream().anyMatch(b -> b.getHotelName().equals("Marriott Marquis")));
    }

    @Test
    @DisplayName("Should return empty list if no bookings found for search")
    void shouldReturnEmptyListForNotFoundSearch() {
        List<Booking> results = bookingService.searchBookingsByHotelName("NonExistentHotel");
        assertTrue(results.isEmpty());
    }

    @Test
    @DisplayName("Should throw IllegalArgumentException for null hotel name on search")
    void shouldThrowExceptionForNullHotelNameOnSearch() {
        assertThrows(IllegalArgumentException.class, () -> bookingService.searchBookingsByHotelName(null));
    }

    @Test
    @DisplayName("Should throw IllegalArgumentException for empty hotel name on search")
    void shouldThrowExceptionForEmptyHotelNameOnSearch() {
        assertThrows(IllegalArgumentException.class, () -> bookingService.searchBookingsByHotelName(""));
    }
}
